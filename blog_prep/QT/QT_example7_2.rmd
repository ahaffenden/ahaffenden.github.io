---
title: "echan_ex7.2: How to Form a Good Cointegrating and Mean-Reverting Pair of Stocks"
author: "Austin Haffenden"
date: '`r Sys.Date()`'
output: 
  md_document:
    variant: markdown_github
---

```{r setup, include=FALSE}
```

##How to Form a Good Cointegrating and Mean-Reverting Pair of Stocks

If you long one security and short another one in the same industry group and
in the right proportion, sometimes the combination (or “spread”) becomes a 
stationary series.

A stationary series is an excellent candidate for a mean-reverting strategy. 
This example teaches you how to determine if two price series are cointegrated 
and, if so, how to find the optimal “hedge ratio” (i.e., the number of shares 
of the second security versus one share of the first security).

The main method used to test for cointegration is called the cointegrating 
augmented Dickey-Fuller test, hence the function name cadf. A detailed
description of this method can be found in the manual also available on the
same web site mentioned earlier.

The following program is available online as epchan.com/book/ example7 2.m

This is taken from exercise 7.2 of E.Chans book Quantitative Trading. 

```{r cl_libs}
rm(list = ls())
library(CADFtest)
```

```{r data_in}

# read a spreadsheet named "GLD.xls" into MATLAB. 
gld_in <- read.csv(file.path("data", "GLD.csv"))

# the first column (starting from the second row) is the trading days in
# format mm/dd/yyyy.
tday1 <- gld_in$Date

# convert the format into yyyymmdd.
tday1 <- format(as.Date(tday1, "%d/%m/%Y"), "%Y%m%d")

# convert the date strings first into cell arrays and then into numeric format.
tday1 <- as.numeric(as.character(tday1))

# the last column contains the adjusted close prices.
adjcls1 <- gld_in$Adj.Close

# read a spreadsheet named "GDX.xls" into MATLAB. 
gdx_in <- read.csv(file.path("data", "GDX.csv"))

# the first column (starting from the second row) is the trading days in 
# format mm/dd/yyyy.
tday2 <- gdx_in$Date

# convert the format into yyyymmdd.
tday2 <- format(as.Date(tday2, "%d/%m/%Y"), "%Y%m%d")

# convert the date strings first into cell arrays and then into numeric format.
tday2 <- as.numeric(as.character(tday2))

# the last column contains the adjusted close prices.
adjcls2 <- gdx_in$Adj.Close


```

```{r merge}
# find all the days when either GLD or GDX has data.
tday <- sort(union(tday1, tday2))
adjcls <- matrix(NaN, length(tday), 2)
#========================================
# tday1
foo <- dplyr::intersect(tday1, tday)

# idx1 is the indices of tday1
idx1 <- match(foo, tday1)

# idx is the indices of tday
idx <- match(foo, tday)

adjcls[idx, 1] <- adjcls1[idx1]

#========================================
# tday2
foo <- dplyr::intersect(tday2, tday)

# idx1 is the indices of tday2
idx2 <- match(foo, tday2)

# idx is the indices of tday
idx <- match(foo, tday)

adjcls[idx, 2] <- adjcls2[idx2]
```

```{r calcs}
#========================================

# days where any one price is missing
baddata <- which(rowSums(is.na(adjcls))>0)

# eliminate days when any return is missing
#ret <- ret[-baddata,]
tday <- tday[-baddata]
adjcls <- adjcls[-baddata,]

vnames <- c('GLD', 'GDX')

```

```{r cadf}
# run cointegration check using augmented Dickey-Fuller test
# res=cadf(adjcls(:, 1), adjcls(:, 2), 0, 1); 
res <- CADFtest::CADFtest(adjcls[,1]~adjcls[,2)
res

```




prt(res, vnames); 

% Output from cadf function:

%  Augmented DF test for co-integration variables:                        GLD,GDX  
% CADF t-statistic        # of lags   AR(1) estimate 
%      -3.35698533                1        -0.060892 
% 
%    1% Crit Value    5% Crit Value   10% Crit Value 
%           -3.819           -3.343           -3.042 

% The t-statistic of -3.36 which is in between the 1% Crit Value of -3.819
% and the 5% Crit Value of -3.343 means that there is a better than 95%
% probability that these 2 time series are cointegrated.

results=ols(adjcls(:, 1), adjcls(:, 2)); 

hedgeRatio=results.beta
z=results.resid;

% A hedgeRatio of 1.6766 was found. I.e. GLD=1.6766*GDX + z, where z can be interpreted as the
% spread GLD-1.6766*GDX and should be stationary.

plot(z); % This should produce a chart similar to Figure 7.4.