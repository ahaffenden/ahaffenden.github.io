---
title: 'e_chan_ex3.6: Trading of GLD and GDX'
author: "Austin Haffenden"
date: "July 15, 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

This example illustrates how to separate the data into a training set and a
test set. 

We will backtest a pair-trading strategy and optimize its parameters
on the training set and look at the effect on the test set.
GLD versus GDX is a good candidate for pair trading because GLD
reflects the spot price of gold, and GDX is a basket of gold-mining
stocks. It makes intuitive sense that their prices should move in tandem.

E. Chan has discussed this pair of ETFs extensively on his blog in connec-
tion with cointegration analysis (see, e.g., epchan.blogspot.com/2006/11/reader-suggested-possible-trading.html). 

Cointegration analysis on the training set is covered in Chapter 7 of the 
book and is used to determine if the spread formed by long GLD and short 
GDX is mean reverting. In this example we will perform a regression analysis
on the training set to determine the hedge ratio between GLD and GDX, and then
define entry and exit thresholds for a pair-trading strategy. We will see how 
optimising these thresholds on the training set changes the performance on the
test set.

We will use a function, lag1, to lag the time series by one time period. 

```{r code}
# make sure previously defined variables are erased.
rm(list = ls())

# read a spreadsheet named "GLD.xls" into MATLAB. 
gld_in <- read.csv(file.path("data", "GLD.csv"))

# the first column (starting from the second row) is the trading days in format mm/dd/yyyy.
tday_gld <- gld_in$Date

# convert the format into yyyymmdd.
tday_gld <- format(as.Date(tday_gld, "%d/%m/%Y"), "%Y%m%d")
head(tday_gld)

# convert the date strings first into cell arrays and then into numeric format.
tday_gld <- as.numeric(as.character(tday_gld))
head(tday_gld)

# the last column contains the adjusted close prices.
cls_gld <- gld_in$Adj.Close
head(cls_gld)

gld_dat <- data.frame(tday = tday_gld,
                      cls_gld = cls_gld)

# read a spreadsheet named "GDX.xls" into MATLAB. 
gdx_in <- read.csv(file.path("data", "GDX.csv"))

# the first column (starting from the second row) is the trading days in format mm/dd/yyyy.
tday_gdx <- gdx_in$Date

# convert the format into yyyymmdd.
tday_gdx <- format(as.Date(tday_gdx, "%d/%m/%Y"), "%Y%m%d")
head(tday_gdx)

# convert the date strings first into cell arrays and then into numeric format.
tday_gdx <- as.numeric(as.character(tday_gdx))
head(tday_gdx)

# the last column contains the adjusted close prices.
cls_gdx <- gdx_in$Adj.Close
head(cls_gdx)

# dataframe of the data
gdx_dat <- data.frame(tday = tday_gdx,
                   cls_gdx = cls_gdx)

# find the intersection of the two data sets, and sort them in ascending order
# by the time
#int_sort <- sort(intersect(tday_gld, tday_gdx))
library(dplyr)
all_dat <- left_join(gdx_dat, gld_dat, by = "tday")
all_dat <- all_dat[order(all_dat$tday),]

# think i can delete these
# cl1=adjcls1(idx1) 
# 
# cl2=adjcls2(idx2)  

# # step one of look-forward bias check
# cutoff=60 # number of most recent trading days to cut off 
# tday(end-cutoff+1:end, :)=[] # remove the last cutoff number of days.
# cl1(end-cutoff+1:end, :)=[]
# cl2(end-cutoff+1:end, :)=[]

# define indices for training set
trainset <- 1:252 

# define indices for test set
testset <- length(trainset)+1:nrow(all_dat) 

vnames=strvcat('GLD', 'GDX')

# test for cointegration of GLD and GDX in the trainset.
# res=cadf(cl1(trainset), cl2(trainset), 0, 1)
# 
# prt(res, vnames)

# determines the hedge ratio on the trainset
# use regression function
results <- lm(all_dat[trainset, "cls_gld"]~all_dat[trainset, "cls_gdx"])
hedgeRatio <- results$coefficients[2]

# spread = GLD - hedgeRatio*GDX
spread <- all_dat[, "cls_gld"] - 
  hedgeRatio*all_dat[, "cls_gdx"] 

plot(spread[trainset])

plot(spread[testset])

# mean  of spread on trainset
spreadMean <- mean(spread[trainset]) 

# standard deviation of spread on trainset
spreadStd <- sd(spread[trainset]) 

# z-score of spread
zscore <- (spread - spreadMean) / spreadStd 

# buy spread when its value drops below 2 standard deviations.
longs <- zscore <= -2 

# short spread when its value rises above 2 standard deviations.
shorts <-  zscore >= 2 

# exit any spread position when its value is within 1 standard deviation of 
# its mean.
exits <- abs(zscore) <= 1 

# initialize positions array
# positions=NaN(length(tday), 2) 
positions <- matrix(rep(NaN), nrow(all_dat), 2)
                 
# looks like there is a matlab package in r that includes the
# repmat function but for now
repmat = function(X, m) {
  mx = dim(X)[1]
  matrix(t(matrix(X, mx)), 
         mx*m,
         byrow = TRUE)
  
}

# long entries
positions[shorts, ] <- repmat(matrix(-1 1), 
                              [length(find(shorts)) 1])


# short entries
positions(longs,  :)=repmat([1 -1], [length(find(longs)) 1]) 

# exit positions
positions(exits,  :)=zeros(length(find(exits)), 2)

# ensure existing positions are carried forward unless there is an exit signal
positions=fillMissingData(positions) 

# combine the 2 price series
cl=[cl1 cl2] 
dailyret=(cl - lag1(cl))./lag1(cl)

pnl=sum(lag1(positions).*dailyret, 2)

# the Sharpe ratio on the training set should be about 2.9
sharpeTrainset=sqrt(252)*mean(pnl(trainset(2:end)))./std(pnl(trainset(2:end))) 

# the Sharpe ratio on the test set should be about 1.0
sharpeTestset=sqrt(252)*mean(pnl(testset))./std(pnl(testset)) 

plot(cumsum(pnl(testset)))

# # step two of look-forward-bias check
# oldoutput=load('example3_6_positions')
# oldoutput.positions(end-cutoff+1:end, :)=[]
#  
# if (any(positions~=oldoutput.positions))
#     fprintf(1, 'Program has look-forward-bias!\n')
# end

```

## Lag1 function 

Original Matlab code
```{r lag1_m, echo=FALSE}
# function y=lag(x)
# % y=lag(x)
# % 
# % written by:
# % Ernest Chan
# %
# % Author of ?Quantitative Trading: 
# % How to Start Your Own Algorithmic Trading Business?
# %
# % ernest@epchan.com
# % www.epchan.com
# 
# if (isnumeric(x))
#     y=[NaN(1,size(x,2))x(1:end-1, :)] % populate the first entry with NaN
# elseif (ischar(x))
#     y=[repmat('',[1 size(x,2)])x(1:end-1, :)] % populate the first entry with ''
# else
#     error('Can only be numeric or char array')
# end.
```